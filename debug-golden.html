<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Golden Tests – Behaviour Trip-Wire</title>
  <style>
    body { font-family: monospace; background: #1a1a1a; color: #e0e0e0; padding: 2rem; }
    h1 { color: #fff; }
    .instructions { color: #888; margin-bottom: 2rem; }
  </style>
</head>
<body>
  <h1>Golden Tests – Behaviour Trip-Wire</h1>
  <p class="instructions">Open the browser console (Cmd+Option+J / Ctrl+Shift+J) to see output.</p>

  <script type="module">
    import { generateRamp } from './assets/js/colorModels/index.js';
    import {
      hexToOklch,
      hexToSrgb, srgbToLinearRgb, linearRgbToOklab
    } from './assets/js/colorModels/convert.js';

    // ── Helpers ──────────────────────────────────────────────

    /** Convert hex to OKLab {L, a, b} */
    function hexToOklab(hex) {
      return linearRgbToOklab(srgbToLinearRgb(hexToSrgb(hex)));
    }

    /** ΔE in OKLab (simple Euclidean) */
    function deltaE(hex1, hex2) {
      const a = hexToOklab(hex1);
      const b = hexToOklab(hex2);
      return Math.sqrt((a.L - b.L) ** 2 + (a.a - b.a) ** 2 + (a.b - b.b) ** 2);
    }

    // ── Golden cases ─────────────────────────────────────────
    // Blue, red, pink-red, yellow, neutral, teal — all at steps=11.

    const goldenCases = [
      // Blue
      { base: '#2F6FED', temp: +1, steps: 11, mode: 'conservative' },
      { base: '#2F6FED', temp: -1, steps: 11, mode: 'conservative' },
      { base: '#2F6FED', temp: +1, steps: 11, mode: 'painterly' },
      { base: '#2F6FED', temp: -1, steps: 11, mode: 'painterly' },
      // Red
      { base: '#B51A00', temp: +1, steps: 11, mode: 'painterly' },
      { base: '#B51A00', temp: -1, steps: 11, mode: 'painterly' },
      // Pink-red
      { base: '#E63B7A', temp: -1, steps: 11, mode: 'painterly' },
      // Yellow
      { base: '#FEC700', temp: +1, steps: 11, mode: 'conservative' },
      { base: '#FEC700', temp: -1, steps: 11, mode: 'conservative' },
      { base: '#FEC700', temp: -1, steps: 11, mode: 'painterly' },
      // Neutral
      { base: '#e9e9e9', temp: +1, steps: 11, mode: 'conservative' },
      { base: '#e9e9e9', temp: -1, steps: 11, mode: 'conservative' },
      { base: '#e9e9e9', temp: +1, steps: 11, mode: 'painterly' },
      { base: '#e9e9e9', temp: -1, steps: 11, mode: 'painterly' },
      // Teal
      { base: '#47868B', temp: +1, steps: 11, mode: 'conservative' },
      { base: '#47868B', temp: -1, steps: 11, mode: 'conservative' },
      { base: '#47868B', temp: +1, steps: 11, mode: 'painterly' },
      { base: '#47868B', temp: -1, steps: 11, mode: 'painterly' },
    ];

    // ── Run ──────────────────────────────────────────────────

    function runGoldenTests() {
      console.clear();

      let hardFails = 0;
      const warnings = [];   // { base, message }

      // Pre-generate all ramps once
      const ramps = goldenCases.map(tc => ({
        ...tc,
        ramp: generateRamp(tc.base, tc.temp, tc.steps, tc.mode),
      }));

      // Helper to label a case
      const label = tc => `${tc.base} temp=${tc.temp > 0 ? '+1' : '-1'} ${tc.mode}`;

      // ── Tier 1: Hard FAILs ──────────────────────────────

      console.log('='.repeat(60));
      console.log('TIER 1 — HARD CHECKS');
      console.log('='.repeat(60));

      // 1a. Monotonic lightness (strict increase)
      console.log('');
      console.log('1a. Monotonic lightness');
      for (const tc of ramps) {
        let prev = -Infinity;
        for (let i = 0; i < tc.ramp.length; i++) {
          const L = hexToOklch(tc.ramp[i]).L;
          if (L <= prev) {
            hardFails++;
            console.log(`  FAIL  ${label(tc)} — step ${i} L=${L.toFixed(4)} <= prev ${prev.toFixed(4)}`);
          }
          prev = L;
        }
      }
      if (hardFails === 0) console.log('  all pass');

      // 1b. Midpoint anchoring (mid step must equal base hex)
      console.log('');
      console.log('1b. Midpoint anchoring');
      const midFailsBefore = hardFails;
      for (const tc of ramps) {
        const mid = Math.floor(tc.steps / 2);
        const midHex = tc.ramp[mid].toUpperCase();
        const baseHex = tc.base.toUpperCase();
        if (midHex !== baseHex) {
          hardFails++;
          console.log(`  FAIL  ${label(tc)} — base=${baseHex}  mid[${mid}]=${midHex}`);
        }
      }
      if (hardFails === midFailsBefore) console.log('  all pass');

      // ── Tier 2: Soft WARNs ──────────────────────────────

      console.log('');
      console.log('='.repeat(60));
      console.log('TIER 2 — SOFT WARNINGS');
      console.log('='.repeat(60));

      // Collect unique bases that have visible chroma (C >= 0.02 at midpoint).
      const chromaBases = [...new Set(goldenCases.map(tc => tc.base))].filter(base => {
        const oklch = hexToOklch(base);
        return oklch.C >= 0.02;
      });

      // "Top 3 highlights" = last 3 steps.
      const top3 = (steps) => [steps - 3, steps - 2, steps - 1];

      // Tier-2 checks are pragmatic.
      // Near-white highlights have limited chroma headroom in sRGB, so we use a
      // lower ΔE threshold there. Elsewhere we use a higher threshold to avoid
      // “difference for difference’s sake”.

      // Chroma below this: treat hue/tint as meaningless (skip pair if BOTH are below)
      const LOW_C = 0.01;

      // Treat near-white highlights differently (small tints are all you can get)
      const NEAR_WHITE_L = 0.95;

      // Pragmatic ΔE thresholds (tunable)
      const DE_THRESHOLD_NORMAL = 0.03;      // “clearly different” in UI
      const DE_THRESHOLD_NEAR_WHITE = 0.015; // “barely visible tint” near white

      function isNearWhite(hex) {
        return hexToOklch(hex).L >= NEAR_WHITE_L;
      }

      function thresholdForPair(hexA, hexB) {
        // If either swatch is near-white, use the lower threshold.
        return (isNearWhite(hexA) || isNearWhite(hexB))
          ? DE_THRESHOLD_NEAR_WHITE
          : DE_THRESHOLD_NORMAL;
      }

      // Return { maxDE, maxAtStep, comparedAny, comparedPairs }
      function maxDeltaEOverTop3(rampA, rampB, steps) {
        const indices = top3(steps);
        let maxDE = 0;
        let maxAtStep = null;
        let comparedAny = false;
        let comparedPairs = 0;

        for (const i of indices) {
          const hexA = rampA[i];
          const hexB = rampB[i];

          const cA = hexToOklch(hexA).C;
          const cB = hexToOklch(hexB).C;

          // Skip if both near-zero chroma (hue meaningless)
          if (cA < LOW_C && cB < LOW_C) continue;

          comparedAny = true;
          comparedPairs++;

          const de = deltaE(hexA, hexB);
          if (de > maxDE) {
            maxDE = de;
            maxAtStep = i;
          }
        }

        return { maxDE, maxAtStep, comparedAny, comparedPairs };
      }

      // Return the effective threshold for the step that had maxDE (or normal default)
      function thresholdForMaxStep(rampA, rampB, maxAtStep) {
        if (maxAtStep == null) return DE_THRESHOLD_NORMAL;
        return thresholdForPair(rampA[maxAtStep], rampB[maxAtStep]);
      }

      // 2a. Low temperature sensitivity (warm vs cool, same mode)
      console.log('');
      console.log('2a. Temperature sensitivity (warm vs cool, same mode)');

      for (const base of chromaBases) {
        const modes = [...new Set(goldenCases.filter(tc => tc.base === base).map(tc => tc.mode))];
        for (const mode of modes) {
          const warm = ramps.find(tc => tc.base === base && tc.mode === mode && tc.temp > 0);
          const cool = ramps.find(tc => tc.base === base && tc.mode === mode && tc.temp < 0);
          if (!warm || !cool) continue;

          const { maxDE, maxAtStep, comparedAny } = maxDeltaEOverTop3(warm.ramp, cool.ramp, warm.steps);
          const thresh = thresholdForMaxStep(warm.ramp, cool.ramp, maxAtStep);

          if (comparedAny && maxDE < thresh) {
            const msg = `${mode}: max ΔE=${maxDE.toFixed(3)} at step ${maxAtStep} (threshold ${thresh})`;
            warnings.push({ base, message: msg });
            console.log(`  WARN  ${base} ${mode} — ${msg}`);
          }
        }
      }

      // 2b. Low mode separation (conservative vs painterly, same temp)
      console.log('');
      console.log('2b. Mode separation (conservative vs painterly, same temp)');

      for (const base of chromaBases) {
        const temps = [...new Set(goldenCases.filter(tc => tc.base === base).map(tc => tc.temp))];
        for (const temp of temps) {
          const cons = ramps.find(tc => tc.base === base && tc.temp === temp && tc.mode === 'conservative');
          const paint = ramps.find(tc => tc.base === base && tc.temp === temp && tc.mode === 'painterly');
          if (!cons || !paint) continue;

          const { maxDE, maxAtStep, comparedAny } = maxDeltaEOverTop3(cons.ramp, paint.ramp, cons.steps);
          const thresh = thresholdForMaxStep(cons.ramp, paint.ramp, maxAtStep);

          if (comparedAny && maxDE < thresh) {
            const tempLabel = temp > 0 ? 'warm' : 'cool';
            const msg = `${tempLabel}: max ΔE=${maxDE.toFixed(3)} at step ${maxAtStep} (threshold ${thresh})`;
            warnings.push({ base, message: msg });
            console.log(`  WARN  ${base} ${tempLabel} — ${msg}`);
          }
        }
      }

      // ── Summary ─────────────────────────────────────────

      console.log('');
      console.log('='.repeat(60));
      console.log('SUMMARY');
      console.log('='.repeat(60));
      console.log(`  Cases:    ${ramps.length}`);
      console.log(`  FAIL:     ${hardFails}`);
      console.log(`  WARN:     ${warnings.length}`);

      if (warnings.length > 0) {
        console.log('');
        console.log('  Warnings by base:');
        const grouped = {};
        for (const w of warnings) {
          (grouped[w.base] ??= []).push(w.message);
        }
        for (const [base, msgs] of Object.entries(grouped)) {
          console.log(`    ${base}`);
          for (const m of msgs) console.log(`      – ${m}`);
        }
      }

      console.log('');
      if (hardFails > 0) {
        console.log(`❌  ${hardFails} hard fail(s) — see above.`);
      } else {
        console.log('✅  All hard checks pass.');
      }
      console.log('='.repeat(60));
    }

    window.runGoldenTests = runGoldenTests;
    runGoldenTests();
  </script>
</body>
</html>